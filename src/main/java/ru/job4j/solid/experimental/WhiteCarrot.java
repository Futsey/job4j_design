package ru.job4j.solid.experimental;

public class WhiteCarrot extends Carrot {


    /** Логику ранее созданной кухни все сложнее поддерживать
     * из-за постоянной необходимости что-то нарушать и демонстрировать это=))))
     * Поэтому на саму кухню и другие классы внимания уже не обращаем.
     *
     * Создадим конструктор и представим, что морковки в мире очень мало, а потому
     * в родительском классе введем поле weight
     * @see ru.job4j.solid.experimental.Carrot
     *
     * А с белой морковкой и вовсе беда. Нельзя добавлять в блюдо больше,
     *  чем 1 грамм морквы на блюдо. Такими действиями мы нарушим правило подстановки,
     *  так как в наследнике зафиксируем конкретное числовое значение поля, а товарищ Барбара завещала
     *  наследникам целиком и полностью дублировать функционал родителя.
     */
    private int weight;

    public WhiteCarrot(int weight) throws Exception {
        super(1);
        /** Кроме того, можем нарушить принцип подстановки и здесь, проведя валидацию постфактум
         * и выдать некий результат не зашитый в логику класса-родителя
         */
        if (weight > 1) {
            throw new Exception("Нельзя так расточительно к белой морковке относится!! Её мало!");
        }
    }

    /** Также мы могли бы нарезать морковку кубиками (её ведь мало), что упростило бы нам задачу
     * по добавлению белой морковки в суп. Но таким образом мы изменили бы сам объект и он не был
     * бы инвариативным в отношении своего родителя, соответствено получили бы нарушение третьего принципа LSP
     */
    public String dicedCarrot() {
        return "Морква кубиками";
    }
}
